<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interviews</title>
  <style>
    @import url('https://fonts.cdnfonts.com/css/charter');
    body {
      font-family: Charter, 'Bitstream Charter', serif;
      background: #fff;
      color: #1a1a1a;
      line-height: 1.5;
      max-width: 650px;
      margin: 40px auto;
      padding: 0 20px;
    }
    nav {
      margin-bottom: 20px;
    }
    nav ul {
      list-style-type: none;
      padding: 0;
      display: flex;
      gap: 15px;
    }
    nav ul li {
      display: inline;
    }
    nav ul li a {
      text-decoration: none;
      color: #0066cc;
    }
    nav ul li a:hover {
      text-decoration: underline;
    }
    /* Tagline header */
    #tagline {
      font-size: 24px;
      margin-bottom: 20px;
    }
    /* Container for the read-out text */
    #textOutput, #questionText {
      font-size: 20px;
      white-space: pre-wrap;
      margin-top: 20px;
    }
    /* Styling for the blinking bullet span to reserve fixed space */
    .blinkingBullet {
      display: inline-block;
      width: 1em; /* Reserve space so layout doesn't shift */
    }
    /* Center the Start Interview button container */
    #startContainer {
      text-align: center;
      margin-top: 20px;
    }
    /* Interview question container */
    #questionContainer {
      display: none;
      margin-top: 40px; /* moves the response area down */
      text-align: left; /* Align text to the left */
    }
    /* Style for the answer text area */
    #answerText {
      width: 100%;
      max-width: 650px;
      padding: 10px;
      font-size: 16px;
      margin-top: 20px;
      margin-bottom: 20px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    /* Style for buttons */
    button {
      padding: 10px 15px;
      font-size: 16px;
      margin: 5px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #startInterview {
      background-color: #0066cc;
      color: #fff;
      display: none;
    }
    #nextButton {
      background-color: #1100dd;
      color: white;
    }
    #endInterview {
      background-color: #cc0000;
      color: white;
    }
    #nextButton:disabled,
    #endInterview:disabled {
      background-color: #999;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <nav>
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="interviews.html">Interviews</a></li>
      <li><a href="writing.html">Writing</a></li>
      <li><a href="projects.html">Projects</a></li>
      <li><a href="contact.html">Contact</a></li>
    </ul>
  </nav>

  <!-- Instructions read-out text area -->
  <div id="textOutput"></div>

  <!-- Centered Start Interview button container -->
  <div id="startContainer">
    <button id="startInterview">Start Interview</button>
  </div>

  <!-- Interview Question Container -->
  <div id="questionContainer">
    <div id="questionText"></div>
    <textarea id="answerText" placeholder="Record your answer here..."></textarea>
    <br />
    <button id="nextButton">Next</button>
    <button id="endInterview">End Interview</button>
  </div>

  <!-- Review Container (hidden until the interview is done) -->
  <div id="reviewContainer" style="display:none;"></div>

  <script>
    /************* READ-OUT INSTRUCTIONS ****************/
    const instructions = "For each open ended question, please use the buttons to navigate your responses and the text area to record your answer";
    const textOutput = document.getElementById("textOutput");
    const bulletChar = "●";

    // Global variables to control blinking and store the current base text words
    let currentBlinkInterval = null;
    let currentWords = [];

    /**
     * Animate text into the given element (forward animation).
     * When complete, stores the full text as an array in currentWords.
     */
    function animateText(element, text, callback) {
      if (currentBlinkInterval) {
        clearInterval(currentBlinkInterval);
        currentBlinkInterval = null;
      }
      const words = text.split(" ");
      let currentWordIndex = 0;
      element.innerHTML = "";
      
      const wordInterval = setInterval(() => {
        if (currentWordIndex < words.length) {
          const baseText = words.slice(0, currentWordIndex + 1).join(" ");
          element.innerHTML = baseText + ' <span class="blinkingBullet">' + bulletChar + '</span>';
          currentWordIndex++;
        } else {
          clearInterval(wordInterval);
          currentWords = words; // Save for reverse animation.
          let showBullet = true;
          const baseText = words.join(" ");
          currentBlinkInterval = setInterval(() => {
            element.innerHTML = baseText + ' <span class="blinkingBullet">' + (showBullet ? bulletChar : "&nbsp;") + '</span>';
            showBullet = !showBullet;
          }, 500);
          if (callback) callback();
        }
      }, 100);
    }

    /**
     * Animate the deletion of text from the given element (reverse animation).
     * Removes one word at a time until the text is cleared.
     */
    function animateTextReverse(element, callback) {
      if (currentBlinkInterval) {
        clearInterval(currentBlinkInterval);
        currentBlinkInterval = null;
      }
      let words = currentWords.slice();
      const reverseInterval = setInterval(() => {
        if (words.length > 0) {
          words.pop();
          element.innerHTML = words.join(" ") + ' <span class="blinkingBullet">' + bulletChar + '</span>';
        } else {
          clearInterval(reverseInterval);
          element.innerHTML = "";
          if (callback) callback();
        }
      }, 40);
    }

    // Animate the instructions then reveal the Start Interview button.
    animateText(textOutput, instructions, () => {
      document.getElementById("startInterview").style.display = "inline-block";
    });

    /************* INTERVIEW QUESTIONS ****************/
    const questions = [
      // Good Tech questions
      { category: "Good Tech", text: "Identify a piece of technology (app, website, software, physical device, operating system, etc) that you like and that you feel comfortable using." },

      
      // Bad Tech questions
      { category: "Bad Tech", text: "Identify a piece of technology that they don't like and that they don't feel comfortable using." },

      
      // Emotions questions
      { category: "Emotions", text: "How does the prospect of having to use new tech make them feel?" },

    ];

    let currentQuestionIndex = 0;
    const responses = [];

    const questionContainer = document.getElementById("questionContainer");
    const questionText = document.getElementById("questionText");
    const answerText = document.getElementById("answerText");
    const nextButton = document.getElementById("nextButton");
    const endInterviewButton = document.getElementById("endInterview");

    // This function animates in the current question text and then re-enables the Next button.
    function displayQuestion() {
      if (currentQuestionIndex < questions.length) {
        const q = questions[currentQuestionIndex];
        const fullQuestion = `[${q.category}] ${q.text}`;
        questionText.innerHTML = "";
        // Animate text forward; once done, enable the Next and End Interview buttons.
        animateText(questionText, fullQuestion, () => {
          nextButton.disabled = false;
          endInterviewButton.disabled = false;
        });
      }
    }

    // Review the responses once the interview is finished.
    function showReview() {
      const reviewContainer = document.getElementById("reviewContainer");
      reviewContainer.style.display = "block";
      let html = "<h2>Interview Review</h2><ul>";
      responses.forEach(response => {
        html += `<li><strong>[${response.category}] ${response.question}</strong><br/><em>${response.answer}</em></li>`;
      });
      html += "</ul>";
      reviewContainer.innerHTML = html;
    }

    // Next button: animate deletion of the current question, record the answer, then show the next question.
    nextButton.addEventListener("click", () => {
      // Disable buttons immediately.
      nextButton.disabled = true;
      endInterviewButton.disabled = true;
      animateTextReverse(questionText, () => {
        // Record the current response.
        const response = {
          question: questions[currentQuestionIndex].text,
          category: questions[currentQuestionIndex].category,
          answer: answerText.value.trim()
        };
        responses.push(response);
        // Clear the answer field.
        answerText.value = "";
        currentQuestionIndex++;
        if (currentQuestionIndex < questions.length) {
          displayQuestion();
        } else {
          // End of interview: hide the question container and show review.
          questionContainer.style.display = "none";
          showReview();
        }
      });
    });

    // End Interview button: animate deletion, record current answer, then show review immediately.
    endInterviewButton.addEventListener("click", () => {
      // Disable buttons immediately.
      nextButton.disabled = true;
      endInterviewButton.disabled = true;
      animateTextReverse(questionText, () => {
        // Record the current response.
        const response = {
          question: questions[currentQuestionIndex].text,
          category: questions[currentQuestionIndex].category,
          answer: answerText.value.trim()
        };
        responses.push(response);
        // Clear the answer field.
        answerText.value = "";
        // Hide the question container and show review.
        questionContainer.style.display = "none";
        showReview();
      });
    });

    // Start Interview: hide instructions, show questions, and animate the first question.
    document.getElementById("startInterview").addEventListener("click", () => {
      document.getElementById("textOutput").style.display = "none";
      document.getElementById("startInterview").style.display = "none";
      document.getElementById("startContainer").style.display = "none";
      questionContainer.style.display = "block";
      // Disable Next and End Interview until the first question fully appears.
      nextButton.disabled = true;
      endInterviewButton.disabled = true;
      displayQuestion();
    });
  </script>
</body>
</html>
