<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Julia - Your New Reasoning Model</title>
  <!-- Add KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  <!-- Add KaTeX JS -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" crossorigin="anonymous"></script>
  <!-- Add marked library for markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Add marked-katex-extension -->
  <script src="https://cdn.jsdelivr.net/npm/marked-katex-extension/lib/index.umd.js"></script>
  <style>
    :root {
      /* Default primary color – update dynamically via JS when the user changes color1 */
      --avatar-color: #80b2ff;
    }
    /* General Page Styles with a Modern Font */
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      position: relative;
      transition: all 2s ease;
    }
    body.dialogue-mode {
      overflow: auto;
    }
    /* Avatar */
    .viewport {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      transition: all 1s ease;
      cursor: default;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .viewport.speaking {
      transform: translate(-50%, -50%) scale(1.1);
    }
    .viewport.dialogue {
      position: fixed;
      top: 20px;
      left: 20px;
      transform: none;
      width: 80px;
      height: 80px;
      margin: 0;
    }
    .viewport.dialogue.speaking {
      transform: scale(1.1);
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    /* Chat Interface Wrapper – slimmer dialogue box */
    #chatWrapper {
      width: 90%;
      max-width: 600px;
      margin: 0 auto;
      margin-top: calc(50vh + 180px);
      transition: all 2s ease;
      overflow-x: hidden;
    }
    body.dialogue-mode #chatWrapper {
      margin-top: 140px;
    }
    /* Chat Messages */
    #chatContainer {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      max-height: 60vh;
      overflow-y: auto;
    }
    .message {
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 20px;
      line-height: 1.3;
      white-space: normal;
      word-wrap: break-word;
    }
    /* Model messages: centered bubble with left-justified text */
    .model-message {
      background: #000;
      color: #fff;
      margin: 0 auto;
      text-align: left;
      max-width: 90%;
    }
    .model-message.center {
      align-self: center;
    }
    /* User messages: right-justified and narrower */
    .user-message {
      background: #ccc;
      color: #000;
      margin-left: auto;
      text-align: right;
      max-width: 70%;
    }
    /* User Input Container – slimmer and wider input */
    #userInputContainer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #000;
      padding: 10px 20px;
      border: 2px solid #444;
      border-radius: 25px;
      display: flex;
      align-items: center;
      gap: 10px;
      opacity: 0;
      transition: opacity 2s ease;
      z-index: 10;
      width: 90%;
      max-width: 600px;
    }
    body.dialogue-mode #userInputContainer {
      opacity: 1;
    }
    #userInputRow {
      display: flex;
      gap: 10px;
      width: 100%;
      align-items: center;
    }
    /* Changed to textarea for automatic wrapping */
    #userInput {
      flex-grow: 1;
      background: #000;
      color: #fff;
      border: none;
      border-radius: 20px;
      font-size: 16px;
      padding: 8px 12px;
      caret-color: #fff;
      resize: none;
      overflow: hidden;
      width: 100%;
    }
    /* Remove highlighting on focus */
    #userInput:focus {
      outline: none;
      box-shadow: none;
    }
    #userInput::placeholder {
      color: #444;
    }
    /* Send Button as a circle that scales on click and transitions background-color */
#sendButton {
  width: 40px;
  height: 40px;
  border: none;
  background: #444;
  cursor: pointer;
  padding: 8px;
  box-sizing: border-box;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.2s ease, background-color 0.2s ease;
  outline: none;
  clip-path: inset(0 round 15px); /* Clips the button into a squircle shape */
}

    #sendButton:active {
      transform: scale(1.2);
    }
    /* Blinking bullet effect */
    .blinkingBullet {
      animation: blink 1s step-start infinite;
      margin-left: 5px;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    /* Edit Avatar Button */
    #editAvatarButton {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #444;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      z-index: 20;
    }
    /* Avatar Editor Control Panel */
    #controlPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.75);
      padding: 10px;
      border-radius: 8px;
      color: #fff;
      font-size: 12px;
      z-index: 30;
      max-height: 90%;
      overflow-y: auto;
      cursor: move;
      display: none;
    }
    #controlPanel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      cursor: move;
    }
    .control-group {
      margin-bottom: 10px;
      border-bottom: 1px solid #555;
      padding-bottom: 8px;
    }
    .control-group:last-of-type {
      border-bottom: none;
    }
    .control-group label {
      display: block;
      margin-bottom: 6px;
    }
    .control-group input[type="range"] {
      width: 200px;
      margin-top: 4px;
    }
    .control-group small {
      display: block;
      margin-top: 4px;
      color: #ccc;
    }
    .color-picker {
      width: 100%;
      height: 30px;
      border: none;
      padding: 0;
      margin: 4px 0;
      background: none;
      cursor: pointer;
    }
    /* Markdown and Code Box Styles */
    .message-content {
      white-space: pre-wrap;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
      line-height: 1.3;
    }
    .message-content > * {
      margin: 0;
      padding: 0;
    }
    .message-content code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', Courier, monospace;
    }
    .message-content pre {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;
    }
    .message-content pre code {
      background: none;
      padding: 0;
    }
    /* Reimagined Thinking Box Styles */
    .thinking-box {
      display: flex;
      flex-direction: column;
      border: 2px solid var(--avatar-color);
      border-radius: 15px;
      overflow: hidden;
      background: #000;
      margin-bottom: 5px;
      max-height: 100px; /* Collapsed height */
    }
    .thinking-box.expanded {
      max-height: none;
    }
    .thinking-box-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      font-size: 14px;
      color: #fff;
    }
    .thinking-box-header .header-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .thinking-box-header .header-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .thinking-box-header .dropdown-arrow {
      cursor: pointer;
      transition: transform 0.3s ease;
      font-size: 14px;
    }
    .thinking-box-content {
      padding: 6px 8px;
      font-size: 14px;
      color: #fff;
      line-height: 1.3;
      flex-grow: 1;
      overflow-y: auto;
    }
    .thinking-box:not(.expanded) .thinking-box-content {
      padding-bottom: 0; /* Remove bottom padding when collapsed */
      overflow-y: hidden; /* Clip content without scrollbar */
      -webkit-mask-image: linear-gradient(to bottom, black 0%, black 90%, transparent 100%);
      mask-image: linear-gradient(to bottom, black 0%, black 90%, transparent 100%);
    }
    .thinking-box.expanded .thinking-box-content {
      -webkit-mask-image: none; /* Remove fade when expanded */
      mask-image: none;
    }
    .thinking-box-content > * {
      margin: 0; /* Remove margins from child elements like <p> */
    }
  </style>
  <script>
    // Configure marked options with KaTeX extension
    const katexOptions = {
      throwOnError: false,
      displayMode: true,
      output: 'html'
    };

    // Unified LaTeX extension that handles both inline and block math
    const latexExtension = {
      name: 'latex',
      level: 'inline',
      start(src) {
        const match = src.match(/(?:\$\$|\$|\\\(|\\\[)/);
        return match?.index;
      },
      tokenizer(src) {
        const blockRule = /^(?:\$\$([\s\S]*?)\$\$|\\\[([\s\S]*?)\\\])/;
        let match = blockRule.exec(src);
        if (match) {
          const [raw, doubleDollar, bracket] = match;
          const text = (doubleDollar || bracket || '').trim();
          return {
            type: 'latex',
            raw,
            text,
            isBlock: true,
            tokens: []
          };
        }
        const inlineRule = /^(?:\$([^\$\n]+?)\$|\\\(([^\)]+?)\\\))/;
        match = inlineRule.exec(src);
        if (match) {
          const [raw, dollar, paren] = match;
          const text = (dollar || paren || '').trim();
          return {
            type: 'latex',
            raw,
            text,
            isBlock: false,
            tokens: []
          };
        }
      },
      renderer(token) {
        try {
          return katex.renderToString(token.text, {
            ...katexOptions,
            displayMode: token.isBlock,
            strict: false
          });
        } catch (error) {
          console.error('KaTeX error:', error);
          return token.isBlock ? 
            '<div class="katex-error">'+ error.message +'</div>' :
            '<span class="katex-error-inline">'+ error.message +'</span>';
        }
      }
    };

    marked.use({ extensions: [latexExtension] });
    marked.setOptions({
      breaks: false,
      gfm: true,
      headerIds: false,
      mangle: false,
      sanitize: false,
      smartLists: true,
      smartypants: true,
      xhtml: false
    });

    // Function to process thought sections in the text (if needed)
    function processThoughts(text) {
      const thoughtRegex = /<think>([\s\S]*?)<\/think>/g;
      let index = 0;
      return text.replace(thoughtRegex, (match, content) => {
        index++;
        const processedContent = marked.parse(content.trim());
        return `<div class="thought-container">
          <div class="thinking-indicator">
            <span class="blinkingBullet">●</span>
            <span>thinking</span>
            <span class="thinking-timer">0.0s</span>
          </div>
          <div class="thought-header" data-thought="${index}" style="display: none">
            <span class="thought-toggle">▶</span><span>Thought Process</span>
          </div>
          <div class="thought-content">${processedContent}</div>
        </div>`;
      });
    }

    // Function to setup thought section click handlers and timers (if needed)
    function setupThoughtHandlers(element) {
      element.querySelectorAll('.thought-container').forEach(container => {
        const thinkingIndicator = container.querySelector('.thinking-indicator');
        const header = container.querySelector('.thinking-header');
        const content = container.querySelector('.thought-content');
        const timer = container.querySelector('.thinking-timer');
        if (!thinkingIndicator || !header || !content) return;
        let startTime = Date.now();
        let timerInterval = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          if (timer) timer.textContent = elapsed + 's';
        }, 100);
        setTimeout(() => {
          clearInterval(timerInterval);
          thinkingIndicator.style.display = 'none';
          header.style.display = 'flex';
          header.addEventListener('click', () => {
            header.querySelector('.thought-toggle').classList.toggle('expanded');
            content.classList.toggle('expanded');
          });
        }, Math.random() * 1500 + 500);
      });
    }
  </script>
</head>
<body>
  <!-- Edit Avatar Button -->
  <button id="editAvatarButton">Edit Avatar</button>
  
  <!-- Avatar Canvas -->
  <div class="viewport" id="avatarViewport">
    <canvas id="fluidCanvas"></canvas>
  </div>
  
  <!-- Chat Interface -->
  <div id="chatWrapper">
    <div id="chatContainer">
      <div id="initialMessageBubble" class="message model-message center"></div>
    </div>
  </div>
  
  <!-- User Input (Rounded Box) -->
  <div id="userInputContainer">
    <div id="userInputRow">
      <textarea id="userInput" placeholder="Type your message..." rows="2"></textarea>
      <button id="sendButton"></button>
    </div>
  </div>
  
  <!-- Avatar Editor Control Panel -->
  <div id="controlPanel">
    <h3 id="dragHandle">Avatar Editor</h3>
    <button id="closeEditorButton" style="background: #444; color: #fff; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Close Editor</button>
    <div class="control-group">
      <label>
        Layer 3 Contribution:
        <input id="layer3Slider" type="range" min="0" max="1" step="0.01" value="1">
      </label>
      <small>0 = two‑color style; 1 = full three‑color style</small>
    </div>
    <div class="control-group">
      <h4>Color 1</h4>
      <input id="color1Picker" class="color-picker" type="color" value="#80b2ff">
    </div>
    <div class="control-group">
      <h4>Color 2</h4>
      <input id="color2Picker" class="color-picker" type="color" value="#3300cc">
    </div>
    <div class="control-group">
      <h4>Color 3</h4>
      <input id="color3Picker" class="color-picker" type="color" value="#ffb233">
    </div>
  </div>
  
  <script>
    /************** WEBGL FLUID SIMULATION WITH AVATAR EDITOR SUPPORT **************/
    (function () {
      const canvas = document.getElementById("fluidCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        console.error("WebGL not supported");
        return;
      }
      
      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      }
      
      const vsSource = 
        `attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
          v_uv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }`;
      
      const fsSource = 
        `precision mediump float;
        uniform float u_time;
        uniform vec2  u_resolution;
        uniform vec2  u_mouse;
        uniform float u_click;
        uniform vec3  u_color1;
        uniform vec3  u_color2;
        uniform vec3  u_color3;
        uniform float u_layer3;
        varying vec2 v_uv;
        
        float random(in vec2 st) {
          return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);
        }
        float noise(in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = smoothstep(0.0, 1.0, f);
          return mix(a, b, u.x) +
                 (c - a) * u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }
        
        void main() {
          vec2 st = v_uv * 3.0;
          vec2 drift;
          drift.x = noise(vec2(u_time * 0.4, st.y)) - 0.5;
          drift.y = noise(vec2(st.x, u_time * 0.4)) - 0.5;
          st += drift * 0.3;
          
          float n1 = noise(st + u_time * 0.2);
          float n2 = noise(st * 1.5 - u_time * 0.3);
          float combinedNoise = mix(n1, n2, 0.5);
          float baseMask = smoothstep(0.35, 0.65, combinedNoise);
          
          float d = distance(v_uv, u_mouse);
          float interactiveRepel = (1.0 - smoothstep(0.0, 0.3, d)) * u_click * 0.3;
          float mixFactor = clamp(baseMask - interactiveRepel, 0.0, 1.0);
          
          vec3 twoColor = mix(u_color1, u_color2, mixFactor);
          float bubbleWeight = exp(-pow((mixFactor - 0.5)/0.05, 2.0));
          vec3 threeColor = mix(twoColor, u_color3, bubbleWeight);
          vec3 finalColor = mix(twoColor, threeColor, u_layer3);
          
          gl_FragColor = vec4(finalColor, 1.0);
        }`;
      
      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link error:", gl.getProgramInfoLog(program));
        return;
      }
      gl.useProgram(program);
      
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
      
      const positionLocation = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      
      const u_timeLoc       = gl.getUniformLocation(program, "u_time");
      const u_resolutionLoc = gl.getUniformLocation(program, "u_resolution");
      const u_mouseLoc      = gl.getUniformLocation(program, "u_mouse");
      const u_clickLoc      = gl.getUniformLocation(program, "u_click");
      const u_color1Loc     = gl.getUniformLocation(program, "u_color1");
      const u_color2Loc     = gl.getUniformLocation(program, "u_color2");
      const u_color3Loc     = gl.getUniformLocation(program, "u_color3");
      const u_layer3Loc     = gl.getUniformLocation(program, "u_layer3");
      
      let color1 = { r: 0.512, g: 0.71, b: 1.0 };
      let color2 = { r: 0.202, g: 0.3, b: 0.8 };
      let color3 = { r: 0.502, g: 0.7, b: 1.0 };
      let layer3 = 1.0;
      
      let startTime = Date.now();
      
      function render() {
        resizeCanvas();
        const time = (Date.now() - startTime) / 1000;
        gl.uniform1f(u_timeLoc, time);
        gl.uniform2f(u_resolutionLoc, canvas.width, canvas.height);
        gl.uniform2f(u_mouseLoc, 0.5, 0.5);
        gl.uniform1f(u_clickLoc, 0.0);
        gl.uniform3f(u_color1Loc, color1.r, color1.g, color1.b);
        gl.uniform3f(u_color2Loc, color2.r, color2.g, color2.b);
        gl.uniform3f(u_color3Loc, color3.r, color3.g, color3.b);
        gl.uniform1f(u_layer3Loc, layer3);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
      
      function hexToRgb(hex) {
        hex = hex.replace(/^#/, '');
        if (hex.length !== 6) {
          console.error("Invalid hex color:", hex);
          return { r: 0, g: 0, b: 0 };
        }
        const bigint = parseInt(hex, 16);
        return {
          r: ((bigint >> 16) & 255) / 255,
          g: ((bigint >> 8) & 255) / 255,
          b: (bigint & 255) / 255
        };
      }
      
      function setupControls() {
        const layer3Slider = document.getElementById("layer3Slider");
        layer3Slider.addEventListener("input", function() {
          layer3 = parseFloat(this.value);
        });
        
        const color1Picker = document.getElementById("color1Picker");
        const color2Picker = document.getElementById("color2Picker");
        const color3Picker = document.getElementById("color3Picker");
        
        function updateColors() {
          color1 = hexToRgb(color1Picker.value);
          color2 = hexToRgb(color2Picker.value);
          color3 = hexToRgb(color3Picker.value);
          window.avatarColor = color1;
          // Update the CSS variable for the avatar's primary color:
          document.documentElement.style.setProperty(
            '--avatar-color',
            `rgb(${Math.round(color1.r * 255)}, ${Math.round(color1.g * 255)}, ${Math.round(color1.b * 255)})`
          );
        }
        
        color1Picker.addEventListener("input", updateColors);
        color2Picker.addEventListener("input", updateColors);
        color3Picker.addEventListener("input", updateColors);
        
        updateColors();
      }
      setupControls();
      
      (function makeDraggable() {
        const panel = document.getElementById("controlPanel");
        const handle = document.getElementById("dragHandle");
        let isDragging = false;
        let startX, startY, origX, origY;
        handle.addEventListener("mousedown", function(e) {
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          const rect = panel.getBoundingClientRect();
          origX = rect.left;
          origY = rect.top;
          e.preventDefault();
        });
        document.addEventListener("mousemove", function(e) {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          panel.style.left = (origX + dx) + "px";
          panel.style.top = (origY + dy) + "px";
          panel.style.right = "auto";
        });
        document.addEventListener("mouseup", function() {
          isDragging = false;
        });
      })();
      
      const editAvatarButton = document.getElementById("editAvatarButton");
      const controlPanel = document.getElementById("controlPanel");
      const closeEditorButton = document.getElementById("closeEditorButton");
      
      editAvatarButton.addEventListener("click", function() {
        controlPanel.style.display = "block";
      });
      
      closeEditorButton.addEventListener("click", function() {
        controlPanel.style.display = "none";
      });
      
    })();
  </script>
  
  <script>
    /*************** CHAT AND DIALOGUE LOGIC WITH THOUGHT PROCESS DISPLAY ***************/
    // Global conversation history – starts with a system message.
    let conversationHistory = [
      {
        role: "system",
        content: "You are Julia, a powerful and friendly AI reasoning model developed by the Julia Research Group. Particularly you are the julia-nano-reasoner-1-70B model."
      }
    ];
    
    async function streamModelResponse(userText, contentElement, bulletElement) {
      const sendButton = document.getElementById("sendButton");
      if (window.avatarColor) {
        sendButton.style.backgroundColor = `rgb(${window.avatarColor.r * 255}, ${window.avatarColor.g * 255}, ${window.avatarColor.b * 255})`;
      }
      try {
        const avatar = document.getElementById("avatarViewport");
        avatar.classList.add("speaking");
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Add the user's message to conversation history.
        conversationHistory.push({ role: "user", content: userText });
        
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'Authorization': 'Bearer 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'
          },
          body: JSON.stringify({
            model: "deepseek-r1-distill-llama-70b",
            messages: conversationHistory,
            stream: true
          })
        });
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullResponse = "";
        let thinkingContent = "";
        let visibleResponse = "";
        let inThought = false;
        
        // Set up the contentElement with the reimagined thinking box and visible content
        contentElement.innerHTML = `
          <div class="thinking-box">
            <div class="thinking-box-header">
              <div class="header-left">
                <span class="blinkingBullet">●</span>
                <span class="header-text">Thinking</span>
              </div>
              <div class="header-right">
                <span class="thinking-timer">0.0s</span>
                <span class="dropdown-arrow">▼</span>
              </div>
            </div>
            <div class="thinking-box-content"></div>
          </div>
          <div class="visible-content"></div>
        `;
        const thinkingBox = contentElement.querySelector('.thinking-box');
        const thinkingContentDiv = contentElement.querySelector('.thinking-box-content');
        const visibleContentDiv = contentElement.querySelector('.visible-content');
        const timerSpan = thinkingBox.querySelector('.thinking-timer');
        const dropdownArrow = thinkingBox.querySelector('.dropdown-arrow');
        
        // Dropdown arrow click handler to toggle expansion of thinking box
        dropdownArrow.addEventListener('click', () => {
          thinkingBox.classList.toggle('expanded');
          if (thinkingBox.classList.contains('expanded')) {
            dropdownArrow.textContent = '▲';
          } else {
            dropdownArrow.textContent = '▼';
          }
        });
        
        // Set up timer for thinking header
        let startTime = Date.now();
        let timerInterval = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          if (timerSpan) timerSpan.textContent = elapsed + 's';
        }, 100);
        
        let done = false;
        while (!done) {
          const { done: streamDone, value } = await reader.read();
          if (streamDone) {
            done = true;
            break;
          }
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop();
          for (let line of lines) {
            if (line.startsWith("data: ")) {
              const jsonStr = line.substring(6).trim();
              if (jsonStr === "[DONE]") {
                done = true;
                break;
              }
              try {
                const parsed = JSON.parse(jsonStr);
                let token = parsed.choices[0].delta?.content || "";
                fullResponse += token;
                // Process thinking tokens
                if (token.includes("<think>")) {
                  inThought = true;
                  token = token.replace("<think>", "");
                }
                if (token.includes("</think>")) {
                  inThought = false;
                  token = token.replace("</think>", "");
                }
                if (inThought) {
                  thinkingContent += token;
                  thinkingContentDiv.innerHTML = marked.parse(thinkingContent);
                  thinkingContentDiv.offsetHeight; // Force reflow to apply styles
                  thinkingContentDiv.scrollTop = thinkingContentDiv.scrollHeight; // Scroll to bottom
                } else {
                  visibleResponse += token;
                  visibleContentDiv.innerHTML = marked.parse(visibleResponse.trim());
                }
                // Scroll chat container to bottom
                document.getElementById("chatContainer").scrollTop = document.getElementById("chatContainer").scrollHeight;
              } catch (e) {
                console.error("Error parsing JSON:", e);
              }
            }
          }
        }
        
        // Stop the timer and update the thinking box header
        clearInterval(timerInterval);
        // Force a reflow to ensure styles are applied correctly from the start
        thinkingBox.classList.add('expanded');
        setTimeout(() => {
          thinkingBox.classList.remove('expanded');
        }, 0);
        thinkingBox.querySelector('.blinkingBullet').style.display = 'none';
        thinkingBox.querySelector('.header-text').textContent = 'Thought Process';
        
        // Add the assistant's response to conversation history
        conversationHistory.push({ role: "assistant", content: fullResponse });
      } catch (error) {
        console.error("Error fetching model response:", error);
        contentElement.innerHTML += " Sorry, something went wrong retrieving the response.";
        setTimeout(() => {
          document.getElementById("avatarViewport").classList.remove("speaking");
        }, 100);
      } finally {
        sendButton.style.backgroundColor = "#444";
        document.getElementById("avatarViewport").classList.remove("speaking");
      }
    }
    
    function addModelResponse(userText) {
      document.querySelectorAll(".model-message .blinkingBullet").forEach(el => {
        el.style.display = "none";
      });
      const modelBubble = document.createElement("div");
      modelBubble.className = "message model-message";
      const contentSpan = document.createElement("span");
      contentSpan.className = "message-content modelContent";
      const bulletSpan = document.createElement("span");
      bulletSpan.className = "blinkingBullet";
      bulletSpan.textContent = "●";
      contentSpan.appendChild(bulletSpan);
      modelBubble.appendChild(contentSpan);
      document.getElementById("chatContainer").appendChild(modelBubble);
      streamModelResponse(userText, contentSpan, bulletSpan);
    }
    
    function addUserMessage(message) {
      const userBubble = document.createElement("div");
      userBubble.className = "message user-message";
      const contentDiv = document.createElement("div");
      contentDiv.className = "message-content";
      const parsedContent = marked.parse(message.trim());
      contentDiv.innerHTML = parsedContent.replace(/\n+$/, '');
      userBubble.appendChild(contentDiv);
      document.getElementById("chatContainer").appendChild(userBubble);
      document.getElementById("chatContainer").scrollTop = document.getElementById("chatContainer").scrollHeight;
    }
    
    function setupUserInput() {
      const sendButton = document.getElementById("sendButton");
      const userInput = document.getElementById("userInput");
      sendButton.addEventListener("click", () => {
        const message = userInput.value.trim();
        if (message === "") return;
        addUserMessage(message);
        userInput.value = "";
        addModelResponse(message);
      });
      userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendButton.click();
        }
      });
    }
    
    function enterDialogueMode() {
      transitionInProgress = true;
      canClickAvatar = false;
      document.body.classList.add("dialogue-mode");
      document.getElementById("avatarViewport").classList.add("dialogue");
    }
    function enterCenterMode() {
      transitionInProgress = true;
      canClickAvatar = false;
      document.getElementById("chatContainer").innerHTML = "";
      document.body.classList.remove("dialogue-mode");
      document.getElementById("avatarViewport").classList.remove("dialogue");
    }
    let canClickAvatar = false;
    let transitionInProgress = false;
    const avatar = document.getElementById("avatarViewport");
    avatar.addEventListener("transitionend", () => {
      if (!transitionInProgress) return;
      transitionInProgress = false;
      if (!document.body.classList.contains("dialogue-mode")) {
        setTimeout(() => {
          const newInitialBubble = document.createElement("div");
          newInitialBubble.id = "initialMessageBubble";
          newInitialBubble.className = "message model-message center";
          document.getElementById("chatContainer").appendChild(newInitialBubble);
          newInitialBubble.textContent = "";
          typeOutText(newInitialBubble, "Hi, I'm Julia, your new reasoning model.", 50, true);
          canClickAvatar = true;
        }, 2000);
      } else {
        setupUserInput();
        canClickAvatar = true;
      }
    });
    
    function onAvatarClick() {
      if (!canClickAvatar || transitionInProgress) return;
      if (document.body.classList.contains("dialogue-mode")) {
        enterCenterMode();
      } else {
        enterDialogueMode();
      }
    }
    avatar.addEventListener("click", onAvatarClick);
    
    window.addEventListener("load", () => {
      setTimeout(() => {
        const initialBubble = document.getElementById("initialMessageBubble");
        typeOutText(initialBubble, "Hi, I'm Julia, your new reasoning model.", 50, true)
          .then(() => {
            canClickAvatar = true;
          });
      }, 2000);
    });
    
    function typeOutText(element, text, interval, animate = false) {
      return new Promise(resolve => {
        const avatar = document.getElementById("avatarViewport");
        if (animate) {
          avatar.classList.add("speaking");
        }
        element.innerHTML = "";
        const textNode = document.createTextNode("");
        element.appendChild(textNode);
        const bulletSpan = document.createElement("span");
        bulletSpan.className = "blinkingBullet";
        bulletSpan.textContent = "●";
        element.appendChild(bulletSpan);
        let i = 0;
        function addChar() {
          if (i < text.length) {
            textNode.nodeValue = text.substring(0, i + 1);
            i++;
            setTimeout(addChar, interval);
          } else {
            if (animate) {
              avatar.classList.remove("speaking");
            }
            resolve();
          }
        }
        addChar();
      });
    }
  </script>
</body>
</html>
