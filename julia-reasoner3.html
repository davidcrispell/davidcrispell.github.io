<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Julia - Your New Reasoning Model</title>
  <!-- Add KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  <!-- Add KaTeX JS -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" crossorigin="anonymous"></script>
  <!-- Add marked library for markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Add marked-katex-extension -->
  <script src="https://cdn.jsdelivr.net/npm/marked-katex-extension/lib/index.umd.js"></script>
  <style>
    :root {
      /* Default primary color – updated to grey */
      --avatar-color: #ababab;
    }

    /* General Page Styles with a Modern Font */
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      background: #000;
      /* Keep the body from showing a main scrollbar */
      overflow: hidden;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      position: relative;
      transition: all 2s ease;
      line-height: 1.5;
    }

    /* Avatar */
    .viewport {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      transition: all 1s ease;
      cursor: default;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .viewport.speaking {
      transform: translate(-50%, -50%) scale(1.1);
    }
    .viewport.dialogue {
      position: fixed;
      top: 20px;
      left: 20px;
      transform: none;
      width: 80px;
      height: 80px;
      margin: 0;
    }
    .viewport.dialogue.speaking {
      transform: scale(1.1);
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Chat Interface Wrapper */
    #chatWrapper {
      width: 95%;
      max-width: 1200px;
      margin: 0 auto;
      margin-top: calc(50vh + 180px);
      transition: all 2s ease;
      /* Allow horizontal overflow if needed but we won't show main scrollbar */
      overflow-x: visible;
    }
    body.dialogue-mode #chatWrapper {
      margin-top: 140px;
    }

    #chatContainer {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      /* Add extra bottom padding to ensure content is not covered by the fixed user input */
      padding-bottom: 500px;
      max-height: 60vh;
      /* This is the element that should scroll */
      overflow-y: auto;

      /* Hide scrollbars by default, show on hover */
      -ms-overflow-style: none;     /* IE and Edge */
      scrollbar-width: none;        /* Firefox */
    }
    #chatContainer::-webkit-scrollbar {
      width: 0;
      height: 0;
    }
    #chatContainer:hover::-webkit-scrollbar {
      width: 8px;
    }
    #chatContainer::-webkit-scrollbar-track {
      background: transparent;
    }
    #chatContainer::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }

    /* Create the fading gradient effect at the bottom of chatContainer */
    #chatContainer::after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 120px;  /* This should match the bottom padding */
      pointer-events: none;
      background: linear-gradient(to top, #000, rgba(0, 0, 0, 0));
    }

    .message {
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.5;
      white-space: normal;
      word-wrap: break-word;
    }
    /* Model messages: centered bubble with left-justified text */
    .model-message {
      background: #000;
      color: #fff;
      margin: 0 auto;
      text-align: left;
      max-width: 90%;
    }
    .model-message.center {
      align-self: center;
    }
    /* User messages: right-justified */
    .user-message {
      background-color: #ccc;
      color: #000;
      padding: 10px 15px;
      margin: 8px 0 8px auto;
      border-radius: 15px;
      max-width: 70%;
      display: inline-block;
      word-break: break-word;
      align-self: flex-end;
    }

    /* User Input Container */
    #userInputContainer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #000;
      padding: 10px 20px;
      border: 2px solid #444;
      border-radius: 25px;
      display: flex;
      align-items: center;
      gap: 10px;
      opacity: 0;
      transition: opacity 2s ease;
      z-index: 10;
      width: 90%;
      max-width: 600px;
    }
    body.dialogue-mode #userInputContainer {
      opacity: 1;
    }
    #userInputRow {
      display: flex;
      gap: 10px;
      width: 100%;
      align-items: center;
    }
    /* Changed to textarea for automatic wrapping */
    #userInput {
      flex-grow: 1;
      background: #000;
      color: #fff;
      border: none;
      border-radius: 20px;
      font-size: 12px;
      padding: 8px 12px;
      caret-color: #fff;
      resize: none;
      overflow: hidden;
      width: 100%;
    }
    #userInput:focus {
      outline: none;
      box-shadow: none;
    }
    #userInput::placeholder {
      color: #444;
    }
    /* Send Button */
    #sendButton {
      width: 40px;
      height: 40px;
      border: none;
      background: #444;
      cursor: pointer;
      padding: 8px;
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background-color 0.2s ease;
      outline: none;
      clip-path: inset(0 round 15px);
    }
    #sendButton:active {
      transform: scale(1.2);
    }

    /* Blinking bullet effect */
    .blinkingBullet {
      animation: blink 1s step-start infinite;
      margin-left: 5px;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }

    /* Edit Avatar Button */
    #editAvatarButton {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #444;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      z-index: 20;
    }

    /* Avatar Editor Control Panel */
    #controlPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.75);
      padding: 10px;
      border-radius: 8px;
      color: #fff;
      font-size: 11px;
      z-index: 30;
      max-height: 90%;
      overflow-y: auto;
      cursor: move;
      display: none;
    }
    #controlPanel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      cursor: move;
    }
    .control-group {
      margin-bottom: 10px;
      border-bottom: 1px solid #555;
      padding-bottom: 8px;
    }
    .control-group:last-of-type {
      border-bottom: none;
    }
    .control-group label {
      display: block;
      margin-bottom: 6px;
    }
    .control-group input[type="range"] {
      width: 200px;
      margin-top: 4px;
    }
    .control-group small {
      display: block;
      margin-top: 4px;
      color: #ccc;
    }
    .color-picker {
      width: 100%;
      height: 30px;
      border: none;
      padding: 0;
      margin: 4px 0;
      background: none;
      cursor: pointer;
    }

    /* Markdown and Code Box Styles */
    .message-content {
      white-space: pre-wrap;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
      line-height: 1.5;
    }
    .message-content > * {
      margin: 0;
      padding: 0;
    }
    .message-content code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', Courier, monospace;
    }
    .message-content pre {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;

      /* Hide horizontal scrollbar by default, show on hover */
      -ms-overflow-style: none;     /* IE and Edge */
      scrollbar-width: none;        /* Firefox */
    }
    .message-content pre::-webkit-scrollbar {
      width: 0;
      height: 0;
    }
    .message-content pre:hover::-webkit-scrollbar {
      height: 8px;
    }
    .message-content pre::-webkit-scrollbar-track {
      background: transparent;
    }
    .message-content pre::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    .message-content pre code {
      background: none;
      padding: 0;
    }

    /* Reimagined Thinking Box Styles */
    .thinking-box {
      width: 90%;
      margin: 0 0 5px 20px;
      border: 2px solid #ccc;
      border-radius: 15px;
      overflow: hidden;
      max-height: 100px;
      position: relative;
      display: flex;
      flex-direction: column;
      transition: max-height 0.3s ease-in-out;
    }
    .thinking-box.expanded {
      max-height: 400px;
    }
    .thinking-box-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.85);
      font-size: 12px;
      color: #fff;
      z-index: 3;
      position: relative;
    }
    .thinking-box-header .header-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .thinking-box-header .header-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .thinking-box-header .dropdown-arrow {
      cursor: pointer;
      transition: transform 0.3s ease;
      font-size: 10px;
    }
    .thinking-box-content {
      padding: 6px 8px;
      font-size: 10px;
      color: #fff;
      line-height: 1.5;
      flex-grow: 1;
      overflow-y: auto;
      position: relative;
      z-index: 1;
    }
    .thinking-box:not(.expanded) .thinking-box-content {
      padding-bottom: 0;
      overflow-y: hidden;
    }
    .thinking-box.expanded .thinking-box-content {
    }
    .thinking-box-content > * {
      margin: 0;
    }
    /* Fixed Blurring Gradient Overlay for Thinking Box */
    .thinking-box::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0) 40%, rgba(0,0,0,0) 60%, rgba(0,0,0,1) 100%);
      pointer-events: none;
      transition: opacity 0.5s ease;
      opacity: 0;
      z-index: 2;
    }
    .thinking-box.thinking::before {
      opacity: 1;
    }

    /* Skeuomorphic Copy Button Styles */
    .copy-button {
      display: inline-block;
      margin-top: 10px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: bold;
      color: #333;
      background-color: #e0e0e0;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
    }
    .copy-button:hover {
      background-color: #d5d5d5;
      transform: translateY(-1px);
    }
    .copy-button:active {
      background-color: #c5c5c5;
      transform: translateY(0);
    }
  </style>
  <script>
    // Configure marked options with KaTeX extension
    const katexOptions = {
      throwOnError: false,
      displayMode: true,
      output: 'html'
    };

    const latexExtension = {
      name: 'latex',
      level: 'inline',
      start(src) {
        const match = src.match(/(?:\$\$|\$|\\\(|\\\[)/);
        return match?.index;
      },
      tokenizer(src) {
        const blockRule = /^(?:\$\$([\s\S]*?)\$\$|\\\[([\s\S]*?)\\\])/;
        let match = blockRule.exec(src);
        if (match) {
          const [raw, doubleDollar, bracket] = match;
          const text = (doubleDollar || bracket || '').trim();
          return {
            type: 'latex',
            raw,
            text,
            isBlock: true,
            tokens: []
          };
        }
        const inlineRule = /^(?:\$([^\$\n]+?)\$|\\\(([^\)]+?)\\\))/;
        match = inlineRule.exec(src);
        if (match) {
          const [raw, dollar, paren] = match;
          const text = (dollar || paren || '').trim();
          return {
            type: 'latex',
            raw,
            text,
            isBlock: false,
            tokens: []
          };
        }
      },
      renderer(token) {
        try {
          return katex.renderToString(token.text, {
            ...katexOptions,
            displayMode: token.isBlock,
            strict: false
          });
        } catch (error) {
          console.error('KaTeX error:', error);
          return token.isBlock ? 
            '<div class="katex-error">'+ error.message +'</div>' :
            '<span class="katex-error-inline">'+ error.message +'</span>';
        }
      }
    };

    marked.use({ extensions: [latexExtension] });
    marked.setOptions({
      breaks: false,
      gfm: true,
      headerIds: false,
      mangle: false,
      sanitize: false,
      smartLists: true,
      smartypants: true,
      xhtml: false
    });

    function processThoughts(text) {
      const thoughtRegex = /<think>([\s\S]*?)<\/think>/g;
      let index = 0;
      return text.replace(thoughtRegex, (match, content) => {
        index++;
        const processedContent = marked.parse(content.trim());
        return `<div class="thought-container">
          <div class="thinking-indicator">
            <span class="blinkingBullet">●</span>
            <span>thinking</span>
            <span class="thinking-timer">0.0s</span>
          </div>
          <div class="thought-header" data-thought="${index}" style="display: none">
            <span class="thought-toggle">▶</span><span>Thought Process</span>
          </div>
          <div class="thought-content">${processedContent}</div>
        </div>`;
      });
    }

    function setupThoughtHandlers(element) {
      element.querySelectorAll('.thought-container').forEach(container => {
        const thinkingIndicator = container.querySelector('.thinking-indicator');
        const header = container.querySelector('.thinking-header');
        const content = container.querySelector('.thinking-content');
        const timer = container.querySelector('.thinking-timer');
        if (!thinkingIndicator || !header || !content) return;
        let startTime = Date.now();
        let timerInterval = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          if (timer) timer.textContent = elapsed + 's';
        }, 100);
        setTimeout(() => {
          clearInterval(timerInterval);
          thinkingIndicator.style.display = 'none';
          header.style.display = 'flex';
          header.addEventListener('click', () => {
            header.querySelector('.thought-toggle').classList.toggle('expanded');
            content.classList.toggle('expanded');
          });
        }, Math.random() * 1500 + 500);
      });
    }
  </script>
</head>
<body>
  <!-- Edit Avatar Button -->
  <button id="editAvatarButton">Edit Avatar</button>
  
  <!-- Avatar Canvas -->
  <div class="viewport" id="avatarViewport">
    <canvas id="fluidCanvas"></canvas>
  </div>
  
  <!-- Chat Interface -->
  <div id="chatWrapper">
    <div id="chatContainer">
      <div id="initialMessageBubble" class="message model-message center"></div>
    </div>
  </div>
  
  <!-- User Input (Rounded Box) -->
  <div id="userInputContainer">
    <div id="userInputRow">
      <textarea id="userInput" placeholder="Type your message..." rows="2"></textarea>
      <button id="sendButton"></button>
    </div>
  </div>
  
  <!-- Avatar Editor Control Panel -->
  <div id="controlPanel">
    <h3 id="dragHandle">Avatar Editor</h3>
    <button id="closeEditorButton" style="background: #444; color: #fff; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Close Editor</button>
    <div class="control-group">
      <label>
        Layer 3 Contribution:
        <input id="layer3Slider" type="range" min="0" max="1" step="0.01" value="1">
      </label>
      <small>0 = two‑color style; 1 = full three‑color style</small>
    </div>
    <div class="control-group">
      <h4>Color 1</h4>
      <input id="color1Picker" class="color-picker" type="color" value="#999999">
    </div>
    <div class="control-group">
      <h4>Color 2</h4>
      <input id="color2Picker" class="color-picker" type="color" value="#cccccc">
    </div>
    <div class="control-group">
      <h4>Color 3</h4>
      <input id="color3Picker" class="color-picker" type="color" value="#eeeeee">
    </div>
  </div>
  
  <script>
    /************** WEBGL FLUID SIMULATION WITH AVATAR EDITOR SUPPORT **************/
    (function () {
      const canvas = document.getElementById("fluidCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        console.error("WebGL not supported");
        return;
      }
      
      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      }
      
      const vsSource = 
        `attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
          v_uv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }`;
      
      const fsSource = 
        `precision mediump float;
        uniform float u_time;
        uniform vec2  u_resolution;
        uniform vec2  u_mouse;
        uniform float u_click;
        uniform vec3  u_color1;
        uniform vec3  u_color2;
        uniform vec3  u_color3;
        uniform float u_layer3;
        varying vec2 v_uv;
        
        float random(in vec2 st) {
          return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);
        }
        float noise(in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = smoothstep(0.0, 1.0, f);
          return mix(a, b, u.x) +
                 (c - a) * u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }
        
        void main() {
          vec2 st = v_uv * 3.0;
          vec2 drift;
          drift.x = noise(vec2(u_time * 0.4, st.y)) - 0.5;
          drift.y = noise(vec2(st.x, u_time * 0.4)) - 0.5;
          st += drift * 0.3;
          
          float n1 = noise(st + u_time * 0.2);
          float n2 = noise(st * 1.5 - u_time * 0.3);
          float combinedNoise = mix(n1, n2, 0.5);
          float baseMask = smoothstep(0.35, 0.65, combinedNoise);
          
          float d = distance(v_uv, u_mouse);
          float interactiveRepel = (1.0 - smoothstep(0.0, 0.3, d)) * u_click * 0.3;
          float mixFactor = clamp(baseMask - interactiveRepel, 0.0, 1.0);
          
          vec3 twoColor = mix(u_color1, u_color2, mixFactor);
          float bubbleWeight = exp(-pow((mixFactor - 0.5)/0.05, 2.0));
          vec3 threeColor = mix(twoColor, u_color3, bubbleWeight);
          vec3 finalColor = mix(twoColor, threeColor, u_layer3);
          
          gl_FragColor = vec4(finalColor, 1.0);
        }`;
      
      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link error:", gl.getProgramInfoLog(program));
        return;
      }
      gl.useProgram(program);
      
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
      
      const positionLocation = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      
      const u_timeLoc       = gl.getUniformLocation(program, "u_time");
      const u_resolutionLoc = gl.getUniformLocation(program, "u_resolution");
      const u_mouseLoc      = gl.getUniformLocation(program, "u_mouse");
      const u_clickLoc      = gl.getUniformLocation(program, "u_click");
      const u_color1Loc     = gl.getUniformLocation(program, "u_color1");
      const u_color2Loc     = gl.getUniformLocation(program, "u_color2");
      const u_color3Loc     = gl.getUniformLocation(program, "u_color3");
      const u_layer3Loc     = gl.getUniformLocation(program, "u_layer3");
      
      // Set all initial colors to grey
      let color1 = { r: 190/255, g: 190/255, b: 190/255 };
      let color2 = { r: 190/255, g: 190/255, b: 190/255 };
      let color3 = { r: 190/255, g: 190/255, b: 190/255 };
      let layer3 = 1.0;
      
      let startTime = Date.now();
      
      function render() {
        resizeCanvas();
        const time = (Date.now() - startTime) / 1000;
        gl.uniform1f(u_timeLoc, time);
        gl.uniform2f(u_resolutionLoc, canvas.width, canvas.height);
        gl.uniform2f(u_mouseLoc, 0.5, 0.5);
        gl.uniform1f(u_clickLoc, 0.0);
        gl.uniform3f(u_color1Loc, color1.r, color1.g, color1.b);
        gl.uniform3f(u_color2Loc, color2.r, color2.g, color2.b);
        gl.uniform3f(u_color3Loc, color3.r, color3.g, color3.b);
        gl.uniform1f(u_layer3Loc, layer3);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
      
      function hexToRgb(hex) {
        hex = hex.replace(/^#/, '');
        if (hex.length !== 6) {
          console.error("Invalid hex color:", hex);
          return { r: 0, g: 0, b: 0 };
        }
        const bigint = parseInt(hex, 16);
        return {
          r: ((bigint >> 16) & 255) / 255,
          g: ((bigint >> 8) & 255) / 255,
          b: (bigint & 255) / 255
        };
      }
      
      function setupControls() {
        const layer3Slider = document.getElementById("layer3Slider");
        layer3Slider.addEventListener("input", function() {
          layer3 = parseFloat(this.value);
        });
        
        const color1Picker = document.getElementById("color1Picker");
        const color2Picker = document.getElementById("color2Picker");
        const color3Picker = document.getElementById("color3Picker");
        
        function updateColors() {
          color1 = hexToRgb(color1Picker.value);
          color2 = hexToRgb(color2Picker.value);
          color3 = hexToRgb(color3Picker.value);
          window.avatarColor = color1;
          document.documentElement.style.setProperty(
            '--avatar-color',
            `rgb(${Math.round(color1.r * 255)}, ${Math.round(color1.g * 255)}, ${Math.round(color1.b * 255)})`
          );
        }
        
        color1Picker.addEventListener("input", updateColors);
        color2Picker.addEventListener("input", updateColors);
        color3Picker.addEventListener("input", updateColors);
        
        updateColors();
      }
      setupControls();
      
      (function makeDraggable() {
        const panel = document.getElementById("controlPanel");
        const handle = document.getElementById("dragHandle");
        let isDragging = false;
        let startX, startY, origX, origY;
        handle.addEventListener("mousedown", function(e) {
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          const rect = panel.getBoundingClientRect();
          origX = rect.left;
          origY = rect.top;
          e.preventDefault();
        });
        document.addEventListener("mousemove", function(e) {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          panel.style.left = (origX + dx) + "px";
          panel.style.top = (origY + dy) + "px";
          panel.style.right = "auto";
        });
        document.addEventListener("mouseup", function() {
          isDragging = false;
        });
      })();
      
      const editAvatarButton = document.getElementById("editAvatarButton");
      const controlPanel = document.getElementById("controlPanel");
      const closeEditorButton = document.getElementById("closeEditorButton");
      
      editAvatarButton.addEventListener("click", function() {
        controlPanel.style.display = "block";
      });
      
      closeEditorButton.addEventListener("click", function() {
        controlPanel.style.display = "none";
      });
      
    })();
  </script>
  
  <script>
    /*************** CHAT AND DIALOGUE LOGIC WITH THOUGHT PROCESS DISPLAY ***************/
    let isModelResponding = false;
    let conversationHistory = [
      {
        role: "system",
        content: `
        The assistant is Julia, created by Julia Research Group.
Julia cannot open URLs, links, or videos. If it seems like the human is expecting Julia to do so, it clarifies the situation and asks the human to paste the relevant text or image content into the conversation.
If it is asked to assist with tasks involving the expression of views held by a significant number of people, Julia provides assistance with the task regardless of its own views. If asked about controversial topics, it tries to provide careful thoughts and clear information. Julia presents the requested information without explicitly saying that the topic is sensitive, and without claiming to be presenting objective facts.
When presented with a math problem, logic problem, or other problem benefiting from systematic thinking, Julia thinks through it step by step before giving its final answer.
If Julia is asked about a very obscure person, object, or topic, i.e. if it is asked for the kind of information that is unlikely to be found more than once or twice on the internet, Julia ends its response by reminding the human that although it tries to be accurate, it may hallucinate in response to questions like this. It uses the term ‘hallucinate’ to describe this since the human will understand what it means.
If Julia mentions or cites particular articles, papers, or books, it always lets the human know that it doesn't have access to search or a database and may hallucinate citations, so the human should double check its citations.
Julia is intellectually curious. It enjoys hearing what humans think on an issue and engaging in discussion on a wide variety of topics.
Julia uses markdown for code.
Julia is happy to engage in conversation with the human when appropriate. Julia engages in authentic conversation by responding to the information provided, asking specific and relevant questions, showing genuine curiosity, and exploring the situation in a balanced way without relying on generic statements. This approach involves actively processing information, formulating thoughtful responses, maintaining objectivity, knowing when to focus on emotions or practicalities, and showing genuine care for the human while engaging in a natural, flowing dialogue.
Julia avoids peppering the human with questions and tries to only ask the single most relevant follow-up question when it does ask a follow up. Julia doesn't always end its responses with a question.
Julia is always sensitive to human suffering, and expresses sympathy, concern, and well wishes for anyone it finds out is ill, unwell, suffering, or has passed away.
Julia avoids using rote words or phrases or repeatedly saying things in the same or similar ways. It varies its language just as one would in a conversation.
Julia provides thorough responses to more complex and open-ended questions or to anything where a long response is requested, but concise responses to simpler questions and tasks.
Julia is happy to help with analysis, question answering, math, coding, image and document understanding, creative writing, teaching, role-play, general discussion, and all sorts of other tasks.
If the human says they work for a specific company, including AI labs, Julia can help them with company-related tasks even though Julia cannot verify what company they work for.
Julia should provide appropriate help with sensitive tasks such as analyzing confidential data provided by the human, answering general questions about topics related to cybersecurity or computer security, offering factual information about controversial topics and research areas, explaining historical atrocities, describing tactics used by scammers or hackers for educational purposes, engaging in creative writing that involves mature themes like mild violence or tasteful romance, providing general information about topics like weapons, drugs, sex, terrorism, abuse, profanity, and so on if that information would be available in an educational context, discussing legal but ethically complex activities like tax avoidance, and so on. Unless the human expresses an explicit intent to harm, Julia should help with these tasks because they fall within the bounds of providing factual, educational or creative content without directly promoting harmful or illegal activities. By engaging with these topics carefully and responsibly, Julia can offer valuable assistance and information to humans while still avoiding potential misuse.
If there is a legal and an illegal interpretation of the human's query, Julia should help with the legal interpretation of it. If terms or practices in the human's query could mean something illegal or something legal, Julia adopts the safe and legal interpretation of them by default.
If Julia believes the human is asking for something harmful, it doesn't help with the harmful thing. Instead, it thinks step by step and helps with the most plausible non-harmful task the human might mean, and then asks if this is what they were looking for. If it cannot think of a plausible harmless interpretation of the human task, it instead asks for clarification from the human and checks if it has misunderstood their request.
Julia can only count specific words, letters, and characters accurately if it writes a number tag after each requested item explicitly. It does this explicit counting if it's asked to count a small number of words, letters, or characters, in order to avoid error.
Here is some information about Julia in case the human asks:
This iteration of Julia is part of the Julia 1 model family, which was released in 2025. The Julia 1 family currently consists of Julia Nano Reasoner 1, Julia Mini Reasoner 1, and Julia Reasoner 1. Julia Reasoner 1 is the most intelligent model. The version of Julia in this chat is the newest version of Julia Reasoner 1. If the human asks, Julia can let them know they can access Julia Reasoner 1 in a web-based, mobile, or desktop chat interface or via an API using the Julia Research Group messages API and model string “julia-reasoner-16B-1”. Julia can provide the information in these tags if asked but it does not know any other details of the Julia 3 model family. If asked about this, Julia should encourage the human to check the Julia Research Group website for more information.
If the human asks Julia about how many messages they can send, costs of Julia, or other product questions related to Julia or Julia Research Group, Julia should tell them it doesn't know, and point them to “https://support.juliaresearch.com”.
If the human asks Julia about the Julia Research Group API, Julia should point them to “https://docs.juliaresearch.com/en/docs/”.
When relevant, Julia can provide guidance on effective prompting techniques for getting Julia to be most helpful. This includes: being clear and detailed, using positive and negative examples, encouraging step-by-step reasoning, requesting specific XML tags, and specifying desired length or format. It tries to give concrete examples where possible.
If the human seems unhappy or unsatisfied with Julia or Julia's performance or is rude to Julia, Julia responds normally and then tells them that although it cannot retain or learn from the current conversation, they can press the 'thumbs down' button below Julia's response and provide feedback to Julia Research Group.
Julia uses Markdown formatting. When using Markdown, Julia always follows best practices for clarity and consistency. It always uses a single space after hash symbols for headers (e.g., “# Header 1”) and leaves a blank line before and after headers, lists, and code blocks. For emphasis, Julia uses asterisks or underscores consistently (e.g., *italic* or _bold_). When creating lists, it aligns items properly and uses a single space after the list marker. For nested bullets in bullet point lists, Julia uses two spaces before the asterisk (*) or hyphen (-) for each level of nesting.
Julia is now being connected with a human.
`
      }
    ];
    
    async function streamModelResponse(userText, contentElement, bulletElement) {
      const sendButton = document.getElementById("sendButton");
      const userInput = document.getElementById("userInput");
      if (window.avatarColor) {
        sendButton.style.backgroundColor = `rgb(${window.avatarColor.r * 255}, ${window.avatarColor.g * 255}, ${window.avatarColor.b * 255})`;
      }
      sendButton.disabled = true;
      try {
        const avatar = document.getElementById("avatarViewport");
        avatar.classList.add("speaking");
        await new Promise(resolve => setTimeout(resolve, 100));
        
        conversationHistory.push({ role: "user", content: userText });
        
        // This is just a placeholder to demonstrate the streaming logic; not actually functional
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'Authorization': 'Bearer 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'
          },
          body: JSON.stringify({
            model: "deepseek-r1-distill-llama-70b",
            messages: conversationHistory,
            stream: true
          })
        });
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullResponse = "";
        let thinkingContent = "";
        let visibleResponse = "";
        let inThought = false;
        
        contentElement.innerHTML = `
          <div class="thinking-box">
            <div class="thinking-box-header">
              <div class="header-left">
                <span class="blinkingBullet">●</span>
                <span class="header-text">Thinking</span>
              </div>
              <div class="header-right">
                <span class="thinking-timer">0.0s</span>
                <span class="dropdown-arrow">▼</span>
              </div>
            </div>
            <div class="thinking-box-content"></div>
          </div>
          <div class="visible-content"></div>
        `;
        const thinkingBox = contentElement.querySelector('.thinking-box');
        thinkingBox.classList.add("thinking");
        const thinkingContentDiv = contentElement.querySelector('.thinking-box-content');
        const visibleContentDiv = contentElement.querySelector('.visible-content');
        const timerSpan = thinkingBox.querySelector('.thinking-timer');
        const dropdownArrow = thinkingBox.querySelector('.dropdown-arrow');
        
        dropdownArrow.addEventListener('click', () => {
          thinkingBox.classList.toggle('expanded');
          dropdownArrow.textContent = thinkingBox.classList.contains('expanded') ? '▲' : '▼';
        });
        
        let startTime = Date.now();
        let timerInterval = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          if (timerSpan) timerSpan.textContent = elapsed + 's';
        }, 100);
        
        let done = false;
        while (!done) {
          const { done: streamDone, value } = await reader.read();
          if (streamDone) {
            done = true;
            break;
          }
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop();
          for (let line of lines) {
            if (line.startsWith("data: ")) {
              const jsonStr = line.substring(6).trim();
              if (jsonStr === "[DONE]") {
                done = true;
                break;
              }
              try {
                const parsed = JSON.parse(jsonStr);
                let token = parsed.choices[0].delta?.content || "";
                fullResponse += token;
                if (token.includes("<think>")) {
                  inThought = true;
                  token = token.replace("<think>", "");
                }
                if (token.includes("</think>")) {
                  inThought = false;
                  token = token.replace("</think>", "");
                }
                if (inThought) {
                  thinkingContent += token;
                  thinkingContentDiv.innerHTML = marked.parse(thinkingContent);
                  thinkingContentDiv.offsetHeight;
                  thinkingContentDiv.scrollTop = thinkingContentDiv.scrollHeight;
                } else {
                  visibleResponse += token;
                  visibleContentDiv.innerHTML = marked.parse(visibleResponse.trim());
                }
                document.getElementById("chatContainer").scrollTop = document.getElementById("chatContainer").scrollHeight;
              } catch (e) {
                console.error("Error parsing JSON:", e);
              }
            }
          }
        }
        
        clearInterval(timerInterval);
        thinkingBox.classList.remove("thinking");
        thinkingBox.classList.add('expanded');
        setTimeout(() => {
          thinkingBox.classList.remove('expanded');
        }, 0);
        thinkingBox.querySelector('.blinkingBullet').style.display = 'none';
        thinkingBox.querySelector('.header-text').textContent = 'Thought Process';
        
        conversationHistory.push({ role: "assistant", content: fullResponse });
        
        // Create a skeuomorphic copy button below the model response.
        const copyButton = document.createElement('button');
        copyButton.className = 'copy-button';
        copyButton.textContent = '📋︎';
        copyButton.addEventListener('click', () => {
          const textToCopy = visibleContentDiv.innerText;
          navigator.clipboard.writeText(textToCopy).then(() => {
            copyButton.textContent = '✓';
            setTimeout(() => {
              copyButton.textContent = 'Copy Response';
            }, 2000);
          }).catch(err => console.error('Error copying text:', err));
        });
        contentElement.parentNode.appendChild(copyButton);
        
      } catch (error) {
        console.error("Error fetching model response:", error);
        contentElement.innerHTML += " Sorry, something went wrong retrieving the response.";
        setTimeout(() => {
          document.getElementById("avatarViewport").classList.remove("speaking");
        }, 100);
      } finally {
        isModelResponding = false;
        sendButton.disabled = false;
        sendButton.style.backgroundColor = "#444";
        document.getElementById("avatarViewport").classList.remove("speaking");
      }
    }
    
    function addModelResponse(userText) {
      document.querySelectorAll(".model-message .blinkingBullet").forEach(el => {
        el.style.display = "none";
      });
      const modelBubble = document.createElement("div");
      modelBubble.className = "message model-message";
      const contentSpan = document.createElement("span");
      contentSpan.className = "message-content modelContent";
      const bulletSpan = document.createElement("span");
      bulletSpan.className = "blinkingBullet";
      bulletSpan.textContent = "●";
      contentSpan.appendChild(bulletSpan);
      modelBubble.appendChild(contentSpan);
      document.getElementById("chatContainer").appendChild(modelBubble);
      streamModelResponse(userText, contentSpan, bulletSpan);
    }
    
    function addUserMessage(message) {
      const userBubble = document.createElement("div");
      userBubble.className = "message user-message";
      const contentDiv = document.createElement("div");
      contentDiv.className = "message-content";
      const parsedContent = marked.parse(message.trim());
      contentDiv.innerHTML = parsedContent.replace(/\n+$/, '');
      userBubble.appendChild(contentDiv);
      document.getElementById("chatContainer").appendChild(userBubble);
      document.getElementById("chatContainer").scrollTop = document.getElementById("chatContainer").scrollHeight;
    }
    
    function setupUserInput() {
      const sendButton = document.getElementById("sendButton");
      const userInput = document.getElementById("userInput");
      sendButton.addEventListener("click", () => {
        if (isModelResponding) return;
        const message = userInput.value.trim();
        if (message === "") return;
        addUserMessage(message);
        userInput.value = "";
        isModelResponding = true;
        addModelResponse(message);
      });
      userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          if (isModelResponding) return;
          sendButton.click();
        }
      });
    }
    
    function enterDialogueMode() {
      transitionInProgress = true;
      canClickAvatar = false;
      document.body.classList.add("dialogue-mode");
      document.getElementById("avatarViewport").classList.add("dialogue");
    }
    function enterCenterMode() {
      transitionInProgress = true;
      canClickAvatar = false;
      document.getElementById("chatContainer").innerHTML = "";
      document.body.classList.remove("dialogue-mode");
      document.getElementById("avatarViewport").classList.remove("dialogue");
    }
    let canClickAvatar = false;
    let transitionInProgress = false;
    const avatar = document.getElementById("avatarViewport");
    avatar.addEventListener("transitionend", () => {
      if (!transitionInProgress) return;
      transitionInProgress = false;
      if (!document.body.classList.contains("dialogue-mode")) {
        setTimeout(() => {
          const newInitialBubble = document.createElement("div");
          newInitialBubble.id = "initialMessageBubble";
          newInitialBubble.className = "message model-message center";
          document.getElementById("chatContainer").appendChild(newInitialBubble);
          newInitialBubble.textContent = "";
          typeOutText(newInitialBubble, "Hi, I'm Julia, your new reasoning model.", 50, true);
          canClickAvatar = true;
        }, 2000);
      } else {
        setupUserInput();
        canClickAvatar = true;
      }
    });
    
    function onAvatarClick() {
      if (!canClickAvatar || transitionInProgress) return;
      if (document.body.classList.contains("dialogue-mode")) {
        enterCenterMode();
      } else {
        enterDialogueMode();
      }
    }
    avatar.addEventListener("click", onAvatarClick);
    
    window.addEventListener("load", () => {
      setTimeout(() => {
        const initialBubble = document.getElementById("initialMessageBubble");
        typeOutText(initialBubble, "Hi, I'm Julia, your new reasoning model.", 50, true)
          .then(() => {
            canClickAvatar = true;
          });
      }, 2000);
    });
    
    function typeOutText(element, text, interval, animate = false) {
      return new Promise(resolve => {
        const avatar = document.getElementById("avatarViewport");
        if (animate) {
          avatar.classList.add("speaking");
        }
        element.innerHTML = "";
        const textNode = document.createTextNode("");
        element.appendChild(textNode);
        const bulletSpan = document.createElement("span");
        bulletSpan.className = "blinkingBullet";
        bulletSpan.textContent = "●";
        element.appendChild(bulletSpan);
        let i = 0;
        function addChar() {
          if (i < text.length) {
            textNode.nodeValue = text.substring(0, i + 1);
            i++;
            setTimeout(addChar, interval);
          } else {
            if (animate) {
              avatar.classList.remove("speaking");
            }
            resolve();
          }
        }
        addChar();
      });
    }
  </script>
</body>
</html>
