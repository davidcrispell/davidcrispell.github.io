<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Julia - Your New Reasoning Model</title>
  <style>
    /* General Page Styles */
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: Charter, 'Bitstream Charter', serif;
      position: relative;
      transition: all 2s ease;
    }
    body.dialogue-mode {
      overflow: auto;
    }

    /* Avatar */
    .viewport {
      width: 300px;
      height: 300px;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      transition: all 1s ease; /* Smooth transitions for transforms / size */
      cursor: default;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    /* While model is speaking, scale to 1.1 in center */
    .viewport.speaking {
      transform: translate(-50%, -50%) scale(1.1);
    }

    /* Dialogue mode: smaller avatar in top-left corner */
    .viewport.dialogue {
      position: fixed;
      top: 20px;
      left: 20px;
      transform: none;
      width: 80px;
      height: 80px;
      margin: 0;
    }
    /* While speaking in top-left, also scale to 1.1 (overrides transform: none) */
    .viewport.dialogue.speaking {
      transform: scale(1.1);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Chat Interface Wrapper */
    #chatWrapper {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      margin-top: calc(50vh + 180px); /* below the centered avatar */
      transition: all 2s ease;
    }
    body.dialogue-mode #chatWrapper {
      margin-top: 140px;
    }

    /* Chat Messages */
    #chatContainer {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
    }
    .message {
      padding: 10px 15px;
      border-radius: 8px;
      max-width: 80%;
      word-wrap: break-word;
      position: relative;
      font-size: 20px;
      line-height: 1.3;
    }
    .model-message.center {
      align-self: center;
      text-align: center;
      background: #000;
      color: #fff;
    }
    .model-message {
      background: #000;
      color: #fff;
      align-self: flex-start;
    }
    .user-message {
      background: #ccc;
      color: #000;
      align-self: flex-end;
    }
    .blinkingBullet {
      display: inline-block;
      width: 1em; /* ensures no shift when toggling bullet vs space */
    }

    /* User Input at Bottom */
    #userInputContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 2s ease;
      background: #000;
      padding: 10px;
    }
    body.dialogue-mode #userInputContainer {
      opacity: 1;
    }
    #userInputRow {
      display: flex;
      gap: 10px;
      max-width: 600px;
      width: 100%;
    }

    /* User text will be white on black */
    #userInput {
      flex-grow: 1;
      background: #000;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      caret-color: #fff;
    }
    #userInput::placeholder {
      color: #444;
    }
    #sendButton {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      background: #444;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }

    /* Prompt with fixed width, so toggling won't shift layout */
    #blinkPrompt {
      display: inline-block;
      width: 1em;
      text-align: center;
      color: #fff;
      font-size: 18px;
      font-family: monospace;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <!-- Julia Avatar -->
  <div class="viewport" id="avatarViewport">
    <canvas id="fluidCanvas"></canvas>
  </div>

  <!-- Chat Interface -->
  <div id="chatWrapper">
    <div id="chatContainer">
      <!-- First model message (initial) -->
      <div id="initialMessageBubble" class="message model-message center"></div>
    </div>
  </div>

  <!-- User Input at Bottom -->
  <div id="userInputContainer">
    <div id="userInputRow">
      <!-- Prompt in sync with bullet blinking, but won't move when toggling -->
      <span id="blinkPrompt">&gt;</span>
      <input type="text" id="userInput" placeholder="Type your message..."/>
      <button id="sendButton">Send</button>
    </div>
  </div>

  <script>
    /*************** WEBGL FLUID SIMULATION ****************/
    (function () {
      const canvas = document.getElementById("fluidCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        console.error("WebGL not supported");
        return;
      }

      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      }

      const vsSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
          v_uv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;
      // New function to fetch the actual model response


      const fsSource = `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_click;
uniform vec3 u_color1;  // Original color 1 (e.g. dark blue)
uniform vec3 u_color2;  // Original color 2 (e.g. light blue)
uniform vec3 u_color3;  // Light purple for bubble refracting effect
varying vec2 v_uv;

float random(in vec2 st) {
  return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);
}

float noise(in vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));
  vec2 u = smoothstep(0.0, 1.0, f);
  return mix(a, b, u.x) +
         (c - a) * u.y * (1.0 - u.x) +
         (d - b) * u.x * u.y;
}

void main() {
  vec2 st = v_uv * 3.0;
  vec2 drift;
  drift.x = noise(vec2(u_time * 0.4, st.y)) - 0.5;
  drift.y = noise(vec2(st.x, u_time * 0.4)) - 0.5;
  st += drift * 0.3;

  float n1 = noise(st + u_time * 0.2);
  float n2 = noise(st * 1.5 - u_time * 0.3);
  float combinedNoise = mix(n1, n2, 0.5);
  float baseMask = smoothstep(0.35, 0.65, combinedNoise);

  float d = distance(v_uv, u_mouse);
  float interactiveRepel = (1.0 - smoothstep(0.0, 0.3, d)) * u_click * 0.3;
  float mixFactor = clamp(baseMask - interactiveRepel, 0.0, 1.0);

  // First blend the two primary colors.
  vec3 baseColor = mix(u_color1, u_color2, mixFactor);

  // Compute a weight that peaks near the midpoint (mixFactor ~ 0.5)
  // Adjust the 0.05 to change the width of the refracting effect.
  float bubbleWeight = exp(-pow((mixFactor - 0.5) / 0.05, 2.0));

  // Blend in the light purple using the computed weight.
  vec3 finalColor = mix(baseColor, u_color3, bubbleWeight);

  gl_FragColor = vec4(finalColor, 1.0);
}


      `;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program failed to link:", gl.getProgramInfoLog(program));
        return;
      }
      gl.useProgram(program);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

      const positionLocation = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      const u_timeLoc       = gl.getUniformLocation(program, "u_time");
      const u_resolutionLoc = gl.getUniformLocation(program, "u_resolution");
      const u_mouseLoc      = gl.getUniformLocation(program, "u_mouse");
      const u_clickLoc      = gl.getUniformLocation(program, "u_click");
      const u_color1Loc     = gl.getUniformLocation(program, "u_color1");
      const u_color2Loc     = gl.getUniformLocation(program, "u_color2");
      const u_color3Loc = gl.getUniformLocation(program, "u_color3");


      let startTime = Date.now();

      function render() {
        resizeCanvas();
        const currentTime = (Date.now() - startTime) / 1000;
        gl.uniform1f(u_timeLoc, currentTime);
        gl.uniform2f(u_resolutionLoc, canvas.width, canvas.height);

        // Hard-coded placeholders
        gl.uniform2f(u_mouseLoc, 0.5, 0.5);
        gl.uniform1f(u_clickLoc, 0.0);

        // Colors
gl.uniform3f(u_color1Loc, 0.502, 0.7, 1.0);
gl.uniform3f(u_color2Loc, 0.302, 0.4, 0.8);
gl.uniform3f(u_color3Loc, 0.602, 0.8, 1.0);  // <-- New lighter blue



        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    })();

    /*************** TEXT & BLINK SYNC ***************/
    const bulletChar = "●";
    let currentBlinkInterval = null;
    let isAnimating = false;
    let currentSkipFunction = null;

    // Controls for enabling/disabling avatar click
    let canClickAvatar = false;         // Must be false during initial message or transitions
    let transitionInProgress = false;   // True while CSS transitions run

    const avatar = document.getElementById("avatarViewport");
    const blinkPrompt = document.getElementById("blinkPrompt");
    const initialBubble = document.getElementById("initialMessageBubble");
    const chatContainer = document.getElementById("chatContainer");

    // Animate text at a certain speed
    function animateText(element, text, callback) {
      isAnimating = true;
      avatar.classList.add("speaking");

      const chars = text.split("");
      let currentCharIndex = 0;
      element.innerHTML = "";

      // Clear any old blinking intervals
      if (currentBlinkInterval) {
        clearInterval(currentBlinkInterval);
        currentBlinkInterval = null;
      }

      const charInterval = setInterval(() => {
        if (currentCharIndex < chars.length) {
          const baseText = chars.slice(0, currentCharIndex + 1).join("");
          element.innerHTML = baseText + ' <span class="blinkingBullet">' + bulletChar + '</span>';
          currentCharIndex++;
        } else {
          // Typing done
          clearInterval(charInterval);
          let showBullet = true;
          const baseText = chars.join("");

          // Start blinking bullet
          currentBlinkInterval = setInterval(() => {
            element.innerHTML = baseText + ' <span class="blinkingBullet">'
              + (showBullet ? bulletChar : '\u00A0') + '</span>';

            // Prompt toggles (but won't shift since #blinkPrompt has fixed width)
            blinkPrompt.textContent = showBullet ? '>' : '\u00A0';

            showBullet = !showBullet;
          }, 500);

          // Stop "speaking" scale
          avatar.classList.remove("speaking");

          isAnimating = false;
          currentSkipFunction = null;
          if (callback) callback();
        }
      }, 50);

      // Allow skipping the typing animation
      currentSkipFunction = function() {
        clearInterval(charInterval);
        if (currentBlinkInterval) {
          clearInterval(currentBlinkInterval);
          currentBlinkInterval = null;
        }
        const baseText = chars.join("");
        element.innerHTML = baseText + ' <span class="blinkingBullet">' + bulletChar + '</span>';
        blinkPrompt.textContent = '>';

        avatar.classList.remove("speaking");
        isAnimating = false;
        currentSkipFunction = null;
        if (callback) callback();
      };
    }

    function addModelResponse(userText) {
      // Remove blinking bullet from old messages
      document.querySelectorAll(".model-message .blinkingBullet").forEach(el => {
        el.style.display = "none";
      });

      const modelBubble = document.createElement("div");
      modelBubble.className = "message model-message";
      chatContainer.appendChild(modelBubble);

      // Animate a dummy response
      animateText(modelBubble, "This is a dummy response to: " + userText);
      modelBubble.scrollIntoView({ behavior: "smooth" });
    }

    function addUserMessage(message) {
      const userBubble = document.createElement("div");
      userBubble.className = "message user-message";
      userBubble.textContent = message;
      chatContainer.appendChild(userBubble);
      userBubble.scrollIntoView({ behavior: "smooth" });
    }

    function setupUserInput() {
      const sendButton = document.getElementById("sendButton");
      const userInput = document.getElementById("userInput");

      sendButton.addEventListener("click", () => {
        if (isAnimating) return;
        const message = userInput.value.trim();
        if (message === "") return;

        addUserMessage(message);
        userInput.value = "";

        // Simulate model reply
        setTimeout(() => {
          addModelResponse(message);
        }, 500);
      });

      userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          if (isAnimating) return;
          sendButton.click();
        }
      });
    }

    /*************** TRANSITION MODES ***************/

    // Move Julia to top-left
    function enterDialogueMode() {
      transitionInProgress = true;
      canClickAvatar = false;
      document.body.classList.add("dialogue-mode");
      avatar.classList.add("dialogue");
    }

    // Move Julia back to center
    function enterCenterMode() {
      transitionInProgress = true;
      canClickAvatar = false;

      // Immediately clear chat so no bubble remains
      chatContainer.innerHTML = "";

      // Hide input
      document.body.classList.remove("dialogue-mode");
      avatar.classList.remove("dialogue");
    }

    // Check when the avatar finishes transitioning
    avatar.addEventListener("transitionend", () => {
      if (!transitionInProgress) return;
      transitionInProgress = false;

      // If we are center mode => we just finished the reverse animation
      if (!document.body.classList.contains("dialogue-mode")) {
        // Wait 2 seconds, then spawn the greeting bubble
        setTimeout(() => {
          const newInitialBubble = document.createElement("div");
          newInitialBubble.id = "initialMessageBubble";
          newInitialBubble.className = "message model-message center";
          chatContainer.appendChild(newInitialBubble);

          // Now animate the greeting
          animateText(
            newInitialBubble,
            "Hi, I'm Julia, your new reasoning model.",
            () => {
              canClickAvatar = true; // re-enable click after greeting
            }
          );
        }, 2000);
      } else {
        // We are in dialogue mode => enable user input & allow user to click again
        setupUserInput();
        canClickAvatar = true;
      }
    });

    // Toggle function for avatar clicks
    function onAvatarClick() {
      if (!canClickAvatar || transitionInProgress) return;

      // If we are in dialogue mode, go back to center
      if (document.body.classList.contains("dialogue-mode")) {
        enterCenterMode();
      } else {
        // Otherwise, go to dialogue mode
        enterDialogueMode();
      }
    }
    async function fetchModelResponse(userText) {
      // Replace '/model-api' with your actual API endpoint
      try {
        const response = await fetch('/model-api', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: userText })
        });
        const data = await response.json();
        // Assume your API returns a JSON object with a "response" property
        return data.response;
      } catch (error) {
        console.error("Error fetching model response:", error);
        return "Sorry, something went wrong retrieving the response.";
      }
    }

    // Modified function to add the model response to the chat
    async function addModelResponse(userText) {
      // Remove blinking bullet from old messages
      document.querySelectorAll(".model-message .blinkingBullet").forEach(el => {
        el.style.display = "none";
      });

      const modelBubble = document.createElement("div");
      modelBubble.className = "message model-message";
      chatContainer.appendChild(modelBubble);

      // Fetch the actual response and animate it as it appears
      const modelReply = await fetchModelResponse(userText);
      animateText(modelBubble, modelReply);
      modelBubble.scrollIntoView({ behavior: "smooth" });
    }

    // In your user input handler, replace the dummy timeout with a direct call:
    sendButton.addEventListener("click", async () => {
      if (isAnimating) return;
      const message = userInput.value.trim();
      if (message === "") return;

      addUserMessage(message);
      userInput.value = "";

      // Fetch and display the actual model response
      addModelResponse(message);
    });
    // Attach the click handler (checks canClickAvatar each time)
    avatar.addEventListener("click", onAvatarClick);

    /*************** INITIAL START-UP ***************/
    window.addEventListener("load", () => {
      // Delay 2 seconds, then type out the initial greeting
      setTimeout(() => {
        animateText(
          initialBubble,
          "Hi, I'm Julia, a new reasoning assistant.",
          () => {
            // Once done typing, user can click to go to dialogue
            canClickAvatar = true;
          }
        );
      }, 2000);
    });
  </script>
</body>
</html>
